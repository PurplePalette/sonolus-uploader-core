/*
 * SweetPotato Server API
 *
 * Sonolusの基本APIを拡張する感じ。 ユーザー認証はFirebaseAuthorizationを通してやる。
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package potato

import (
	"context"
	"encoding/json"
	"log"
	"net/http"

	"cloud.google.com/go/firestore"
	"github.com/PurplePalette/sonolus-uploader-core/utils/request"
	"gopkg.in/go-playground/validator.v9"
)

// EnginesAPIService is a service that implents the logic for the EnginesAPIServicer
// This service should implement the business logic for every endpoint for the EnginesAPI API.
// Include any external packages or services that will be required by this service.
type EnginesAPIService struct {
	firestore *firestore.Client
	cache     *CacheService
	validate  *validator.Validate
}

// NewEnginesAPIService creates a default api service
func NewEnginesAPIService(firestore *firestore.Client, cache *CacheService) EnginesAPIServicer {
	return &EnginesAPIService{firestore: firestore, cache: cache, validate: validator.New()}
}

// AddEngine - Add engine
func (s *EnginesAPIService) AddEngine(ctx context.Context, engineName string, engine Engine) (ImplResponse, error) {
	if !request.IsValidName(engineName) {
		return Response(http.StatusBadRequest, nil), nil
	}
	if err := s.validate.Struct(engineName); err != nil {
		return Response(http.StatusBadRequest, nil), nil
	}
	if s.cache.engines.IsExist(engineName) {
		return Response(http.StatusConflict, nil), nil
	}
	// Force set parameter to valid
	userID, _ := request.GetUserID(ctx)
	engine.UserID = userID
	engine.Name = engineName
	col := s.firestore.Collection("engines")
	// Add engine to cache
	if err := s.cache.engines.Add(engineName, engine); err != nil {
		return Response(http.StatusConflict, nil), nil
	}
	// Add engine to firestore
	if _, err := col.Doc(engineName).Set(ctx, engine); err != nil {
		log.Fatalln("Error posting engine to firestore:", err)
		return Response(500, nil), nil
	}
	return Response(200, nil), nil
}

// EditEngine - Edit engine
func (s *EnginesAPIService) EditEngine(ctx context.Context, engineName string, engine Engine) (ImplResponse, error) {
	if !request.IsValidName(engineName) {
		return Response(http.StatusBadRequest, nil), nil
	}
	if err := s.validate.Struct(engineName); err != nil {
		return Response(http.StatusBadRequest, nil), nil
	}
	userID, _ := request.GetUserID(ctx)
	match, err := s.cache.engines.IsOwnerMatch(engineName, userID)
	if err != nil {
		return Response(http.StatusNotFound, nil), nil
	}
	if !match {
		return Response(http.StatusForbidden, nil), nil
	}
	// Update engine data in firestore
	col := s.firestore.Collection("engines")
	if _, err := col.Doc(engineName).Set(ctx, engine); err != nil {
		log.Fatalln("Error posting engine:", err)
		return Response(500, nil), nil
	}
	// Update engine data in cache
	s.cache.engines.Set(engineName, engine)
	return Response(200, nil), nil
}

// GetEngine - Get engine
func (s *EnginesAPIService) GetEngine(ctx context.Context, engineName string) (ImplResponse, error) {
	eg, err := s.cache.engines.Get(engineName)
	if err != nil {
		return Response(http.StatusNotFound, nil), nil
	}
	parsedEg := eg.(Engine)
	resp := GetEngineResponse{
		Item:        parsedEg,
		Description: parsedEg.Description,
		Recommended: []Engine{},
	}
	return Response(200, resp), nil
}

// GetEngineList - Get engine list
func (s *EnginesAPIService) GetEngineList(ctx context.Context, localization string, page int32, keywords string) (ImplResponse, error) {
	query := request.ParseSearchQuery(keywords)
	pages := s.cache.engines.Pages()
	items, err := s.cache.engines.GetPage(page, query)
	if err != nil {
		log.Fatal(err)
		return Response(500, nil), nil
	}
	var engines []Engine
	err = json.Unmarshal(items, &engines)
	if err != nil {
		return Response(500, nil), nil
	}
	resp := GetEngineListResponse{
		PageCount: pages,
		Items:     engines,
	}
	return Response(200, resp), nil
}
